# Вопросы 58-66


## Вопрос 58

**Что такое множественное наследование, какие могут возникнуть проблемы? Как они решаются?**

**Ответ:** 
1. Наследование при котором класс-потомок имеет более одного родительского класса называется **множественным** (_Multiple inheritance_). Конечно, как и при обычном наследовании производному классу доступны методы и атрибуты в зависимости от типа наследования (`private`, `protected`, `public`). Отметим, что наследование от каждого из родительских классов может быть разным. Для лучшего понимая предлагаем вам взглянуть на следующий пример, в котором представлено множественное наследование класса `D`
    ```c++
    #include <limits>

    class A 
    {
    public:
        int a3;
        const int& get_a3() const { return a3; }
    protected:
        int a2;
        const int& get_a2() const { return a2; }
    private:
        int a1;
        const int& get_a1() const { return a1; }
    };
    class B 
    {
    public:
        int b3;
        const int& get_b3() const { return b3; }
    protected:
        int b2;
        const int& get_b2() const { return b2; }
    private:
        int b1;
        const int& get_b1() const { return b1; }

    };
    class C 
    {
    public:
        int c3;
        const int& get_c3() const { return c3; }
    protected:
        int c2;
        const int& get_c2() const { return c2; }
    private:
        int c1;
        const int& get_c1() const { return c1; }
    };

    class D : private A, protected B, public C 
    {
    protected:
        int d; // внутри класса `D` можно получить доступ к атрибутам и методам наследуемых классов.
        
        void function()
        {
            // методы класса `A`
            d = A::get_a3(); // доступно
            d = A::get_a2(); // доступно
            d = A::get_a1(); // ошибка доступа
            // методы класса `B`
            d = B::get_b3(); // доступно
            d = B::get_b2(); // доступно
            d = B::get_b1(); // ошибка доступа
            // методы класса `C`
            d = C::get_c3(); // доступно
            d = C::get_c2(); // доступно
            d = C::get_c1(); // ошибка доступа
        }
    };
    ```
 
2. Но при множесвенном наследовании может возникнуть проблема, которая получила название "ромбовидное наследование (_diamond inheritance_))". Представим ромбовидное наследование.

    ```c++
    class A {};
    class B : public A {};
    class C : public A {};


    class D : public B, public C {};
    ```
    Пусть в классе `D` будет вызван метод класса `A`, который не был переопределен в классе `D`, но был переопрделен в каждом из классов  `B` и `C`, тогда какой из этих трех методов должен быть вызван?

    (На самом деле c++ не создает такой проблемы. При создании экземпляров классов `B` или `C` сначала будет вызван один из конструкторов класса `A`, и только потом конструкторы производных классов, т.е. сначала будет создан объект типа `A`, а потом объекты производного класса. 
    
    Но тогда при создании экземпляра класса `D` будут созданы экземпляры классов `B` и `C`, что приведет к двойному вызову конструктора класса `A` = будет создано два объекта базового класса: `B::A` и `C::A`. Тогда при использовнии методов класса `A` необходимо указать путь наследования, например `C::A::function()`) 

3. Чтобы решить проблему ромбовидного наследования было введено виртуальное наследование. Мы объявляем наследование классов `B` и `C` от класса `A` виртуальным.
     ```c++
    class A {};
    class B : virtual public A {};
    class C : virtual public A {};


    class D : public B, public C {};
    ```
    Тогда компилятор проследит за созданием только одного объекта класса `A`, что позволит пользоваться его методами без указания пути наследования. 

    **А что если мне неймется и я сделаю так?**
     ```c++
    class A {};
    class B : virtual public A {};
    class C : public A {};


    class D : public B, public C {};
    ```

    Тогда при объявлении объекта класса `D` будут созданы: выртуальный объект класса `A` (не знаю зачем он) и по одному невиртуальному объекту класса `A` по каждому из путей наследования, т.е. объекты `D::B::A` и `D::C::A`. Если не работать с указателями на базовый класс, то действовать можно так же, как и при полностью виртуальном наследовании, иначе если указатель на базовый класс смотрит на объект класса `D` и мы вызываем **виртульный** метод `A::insert(...)`, который был переопределен в классах `B` и `C` как `D::insert(...)` и `C::insert(...)`, то компилятор выдаст ошибку из-за [принципа доминирования](https://en.wikipedia.org/wiki/Dominance_(C%2B%2B)).

А вот [здесь](https://github.com/Igetsuga/programming-practice/blob/master/object-oriented-programming/practice3%5BInheritance%5D.cpp) можно найти пример с ромбовидным наследованием с комментариями.
___

## Вопрос 59

**Виртуальные функции: способы задания, отличия от невиртуаль-ных. Приведите сравнение на простом примере.**
    
**Ответ:** 
1. Зачем нужны виртуальные методы? При работе с указателем на базовый класс мы хотим вызвать метод, который был переопределен в производном классе, тогда если в базовом классе этот метод не объявлен как виртуальный, то будет вызван метод родительского класса, иначе нужный нам у производного. Таким образом, виртульные методы указывают компилятору на переопределенные методы, которые нужно вызвать в данный момент.

2. Чтобы объявить метод виртуальным необходимо использовать ключевое слово `virtual`. Пример, метод `Base::GetPosition()` объявлен виртуальным.
    ```c++
    class Base 
    {
        virtual const int& GetPosition() const final;
    };
    ```

3. Виртуальные методы от невиртуальных отличаются тем, что у первых **динимаческое связвывание**(_разрешение типов во время выполнения программы_), т.е. связываение вызова функции с её определением происходит во время выполнения программы, а у вторых во время компиляции, потому что виртульная функция может быть переопределена в другом месте, и тогда сначала нужно понять какой из всех вариантов вызывать. Чтобы понять какой из всех вариантов вызвать нужен контекст (например, знать на что смотрит указатель на базовый класс), который определяется работой программы. Пример, убрав в нем виртуальность метода базового класса `print()`, мы вызовем метод из базового класса дважды(**проверьте сами**)
    ```c++
    #include <limits>
    #include <iostream>

    class Base 
    {
    public:

        Base() = default;
        ~Base() = default;


        virtual void print() const 
        {
            std::cout << '\n' << "I am frome Base" << '\n';
        }
    };

    class Derived : public Base
    {
    public:

        Derived() = default;
        ~Derived() = default;


        void print() const override
        {
            std::cout << '\n' << "I am frome Derived" << '\n';
        }

    };


    int main()
    {
        Base base;
        Derived derived;

        Base* ptr = &base; ptr->print();
        ptr = &derived; ptr->print();

        return 0;
    }
    ```

    Вывод:

        I am frome Base

        I am frome Derived
___

## Вопрос 60

**Что будет, если в родительском классе функция объявлена как вир-туальная, в унаследованном от него – нет?**
    
**Ответ:** 

   1. Для того, чтобы метод стал виртуальным **необходимо и достаточно**, чтобы он был объявлен виртуальным в базовом классе. Поэтому этот метод будет виртуальным для всех производным структур, где он переопределен. (см. пример из прошлого вопроса)

___

## Вопрос 61

**Имеется иерархия порождения классов A<-B<-C. Что будет в классе C, если в A функция была объявлена как обыкновенная, в B - как чисто вирту-альная, а в C - снова как обыкновенная?**
    
**Ответ:**     
Пусть метод `A::drink()` - обычный. `B::drink()` - чисто виртуальный. В таком случае работа метода `C::drink()` будет напрямую зависеть от того, с каким указателем мы имеем дело. Если указатель на базовый класс имеет тип `A`, то поскольку в классе `A` функция не была объявлена как виртуальная, а указатель смотрит на объект любого из классов `A` или `C`, то будет вызвана функция из базового класса, т.е. из класса `A`. Если указатель имеет тип `B`, а функция чисто-виртуальная (т.е. сам класс чисто-виртуальный) то он может смотреть только на объект класса `C`, в итоге, будет вызван метод из класса `C`. Это показывает следующий пример. 
```c++
#include <limits>
#include <iostream>

class A 
{
public:

	A() = default;
	~A() = default;


	void print() const 
	{
		std::cout << '\n' << "I am frome A" << '\n';
	}
};

class B : public A
{
public:

	B() = default;
	~B() = default;


	virtual void print() const = 0;

};

class C : public B 
{
public:

	C() = default;
	~C() = default;


	void print() const override
	{
		std::cout << '\n' << "I am frome C" << '\n';
	}

};

int main()
{
	
	C object_c;

	A* ptr_A = &object_c; ptr_A->print();
	B* ptr_B = &object_c; ptr_B->print();

	return 0;
}
```
Вывод:

    I am frome A

    I am frome C
___

## Вопрос 62

**Виртуальные методы и абстрактные классы: назначение, отличия от обычных.**
    
**Ответ:** 

1. Класс называется абстрактным, если хотябы один из его методов объявлен как чисто-виртульный. Философия абстрактных класов слудующая.
> Абстрактные классы используются в качестве обобщенных концепций, на основе которых можно создавать более конкретные производные классы.

Чтобы объявить метод класса чисто-виртуальным нужно приравнять виртуальную функцию приравнять к 0 во время её объявления.
    
```c++
    virtual void function GetData() = 0;
```
Мы предпочитам объявлять чисто-виртуальные конструкторы и деструкторы. 

   

2. В отличие от стандартных классов у абстрактных есть некоторые ограничения.
    Абстрактные классы нельзя использовать для:
    - переменных и данных членов;
    - типов аргументов;
    - типов возвращаемых функциями значений;
    - типов явных преобразований.
    
    **Другими словами невозможно создать объект абстрактного класса. Однако можно использовать указатели и ссылки на абстрактные типы классов.**
    ___

## Вопрос 63

**Зачем нужны абстрактные классы?**
    
**Ответ:** 

1. см. Вопрос 62

2. Например, удобно будет объявить класс `Млекопитающие` абстрактным. Объвить там чисто-виртуальные методы: кормление молоком, живорождение. Унаследовать от класса `Млекопитающие` классы `Обезьянка`, `Свинка`, `Коровка`, `Кошечка`, `Собачка`, `Человечина`. В каждом из них опрделить методы базового класса.    ___

## Вопрос 64

**Статическое и динамическое связывание в контексте указателей на классы в иерархии порождения и преобразования типов C++.**
    
**Ответ:** 
1. Что такое связывание? Связываением называется соединение компилятором места, где функция была вызвана с тем местом, где она объявлена, а после определена. Когда функция вызывается управление программой в коцне концов переходит ячекам памяти, где эта функция определена. Или еще один пример, привязка переменной к типу тоже является связываением (т.е. `int x` здесь переменная `x` связывается с типом `int`)

2. Есть всего два вида связывания: **статическое**(_ранее_) и **динамическое**(_позднеее_), они уже были затронуты ранее, см. Вопрос 59, но, все равно, здесь еще раз объясним разницу. 

    >Связывание является **статическим**, если оно впервые происходит перед запуском программы и остается неизменным на протяжении ее исполнения.

    >Связывание является **динамическим**, если оно впервые происходит во время исполнения или может измениться во время исполнения программы.

___

## Вопрос 65

**Имеются ли хоть какие-то проверки допустимости преобразований при динамическом связывании?**

**Ответ:** 
___

## Вопрос 66

**Сложное наследование (несколько предков). Последовательность вызовов конструкторов и деструкторов для объектов производного класса в этом случае.**

**Ответ:** 
1. Сложное наследование. Вызов конструкторов сверху-вниз (сначала базовый потом производный).
2. Сложное наследование (не виртуальное). Вызов деструкторов снизу-вверх (сначала производный потом базовый).

    ```c++
    #include <limits>
    #include <iostream>

    class A {
    public:

        A() { std::cout << '\n' << "A constructor"; }
        ~A() { std::cout << '\n' << "A destructor"; }

    };

    class B : public A
    {
    public:

        B() { std::cout << '\n' << "B constructor"; }
        ~B() { std::cout << '\n' << "B destructor"; }

    };

    class C : public B 
    {
    public:

        C() { std::cout << '\n' << "C constructor"; }
        ~C() { std::cout << '\n' << "C destructor"; }

    };

    int main ()
    {
        C object_c;

    return 0;
    }
    ```
    Вывод:
        
        A constructor
        B constructor
        C constructor
        C destructor
        B destructor
        A destructor