# Вопросы 94-99

Некторое предисловие.

Язык программирования называется **строго типизированным**, если в нем разрешены только явные преобразования типов. Т.е. язык программирование не разрешает смешивать сущности разных типов в выражениях и не выполняют никаких автоматических преобразований.

С++ не является строго типизированным языком программирования, поэтому когда вы пишите программу, вы должны убедиться, что она является строго типизированной и это очень важно. Почему ваши программа дожна быть строго типизированной? Зачем нужна строгая типизация?
- Надежность — Вы получите исключение или ошибку компиляции, взамен неправильного поведения.
- Скорость — вместо скрытых(неявных) преобразований, которые могут быть довольно затратными, с сильной типизацией необходимо писать их явно, что заставляет программиста как минимум знать, что этот участок кода может быть медленным.
- Понимание работы программы — опять-же, вместо неявного приведения типов, программист пишет все сам, а значит примерно понимает, что сравнение строки и числа происходит не само-собой и не по-волшебству.
- Определенность — когда вы пишете преобразования вручную вы точно знаете, что вы преобразуете и во что. Также вы всегда будете понимать, что такие преобразования могут привести к потере точности и к неверным результатам.


## Вопрос 94

**Неявные преобразования типа в C++: перечислите, приведите короткие примеры**

**Ответ:** 

Преобразование типа называется **неявным**, если его совершает компилятор без участия программиста.

Когда происходит неявное преобразование типов:
- после вычисления операндов бинарных арифметических, логических, битовых операций, операций сравнения;
- перед выполнением присваивания;
- перед передачей аргумента функции;
- перед возвратом функцией возвращаемого значения;
- после вычисления выражения конструкции `switch` значение приводится к целочисленному типу;
- после вычисления выражений конструкций `if`, `for`, `while`, `do-while` значение приводится к типу `bool`;
- конструкторы преобразования (если он не объявлен с ключевым словом `explicit`)

Примеры:
```c++
int xn = 1;
double xd = 1.05;

if ( xn < xd ) { return 0; }
// 1. xn(int) -> xn(double)
// 2. сравнение
// 3. приведение результата операции сравнения к типу `bool`

int xx = xn + xd;
// 1. xn(int) -> xn(double)
// 2. xn + xd 
// 3. приведение результата сложение к типу `int`

void foo (double x) {
    std::cout << "yoo" << '\n';
}

foo (xd)
// 1. xn(int) -> xn(double)


// Конструктор преобразования
class A {
public:
    // default constructor
    A() = default;

    // default destructor
    ~A() = default; 

    // converted constructor
    A (B object) {
        ...
    }

    // converted constructor
    A (int variable) {
        ...
    }    
}
```

Причем стоить отметить, что в арифметическим операциях с типами разных размеров тип с меньшим размером расширяется(продвигается) в больший тип. Т.е. в наших примерах тип `int` (4 байта) расширется в `double` (8 байт)

## Вопрос 95

**Явные преобразования типа в C++: встроенные формы const_cast, static_cast, dynamic_cast, reinterpret_cast. Правила выбора типа преобразования.**

**Ответ:** 

Преобразование типа называется явным, если это преобразование справоцировано самим программистом. 

1. Сначала дополним ответ на предыдущий вопрос.  
    Конструктор преоброзований, объявленный с ключевым словом `explicit`, можно считать явным конструктором преобразований. Это ключевое слово запрещает компилятору самому вызывать этот конструктор там, где он мог бы это сделать, например, в строке 39. 
    ```c++
    class Complex {
    public:
        
        Complex() = default;
        Complex(double Re, double Im) {
            _Re = Re;
            _Im = Im;
        }
        ~Complex() = default;

        explicit Complex (double Re) { // строка 16
            _Re = Re; 
            _Im = 0;
        }

        friend void _print(const Complex &complex);

    private:
        double _Re;
        double _Im;
    };

    void _print(const Complex &complex) {
            std::cout << '\n' << "Re = " << complex._Re;
            std::cout << '\n' << "Im = " << complex._Im;
    }

    int main() {

        Complex z(23.1, 0.42); _print(z);

        Complex zn(2.0); _print(zn);  // строка 37

        double xn = 1.42; _print(xn); // строка 39

        return 0;
    }
    ```
2. `static_cast`  
   Этот преобразователь можно желательно применять только для типов, которые заранее известны компилятору, т.к. проверка проверка приведения выполняется только во время компиляции, когда компилятор не знает о конструкторах преобразования ваших типов. 
   ```c++
    double d = 1.58947;
    
    // неявное пребразование типов, возможна потеря данных, пользователь об этом не знает
    int i = d;  // warning C4244 possible loss of data
    
    // явное пребразование типов, поторя данных, но пользователь об этом знает
    int j = static_cast<int>(d);       // No warning.
    
    // компилятор не умеет преобразовывать `double` в `std::sring` 
    string s = static_cast<string>(d); // Error C2440:cannot convert from
                                    // double to std:string

    // No error but not necessarily safe.
    Base* b = new Base();
    Derived* d2 = static_cast<Derived*>(b);
   
   ```

3. `dynamic_cast`  
   Этот оператор приведения выполняет безопасное приведение указателя базового класса на указатель типа производного класса. В этом случае проверка приведение возложена на среду разработки(что отрицательно сказывается на эффективности) и выполняется во время работы программы.
   ```c++
    Base* b = new Base();

    // Проверка во время выполнения, действительно ли указатель b имеет тип `Derived*`
    Derived* d3 = dynamic_cast<Derived*>(b);

    // Если предыдущее действие выполнено(b является указателем типа...,) значит, теперь d3 допустимый указатель
    if(d3) {
    // можно безопасно вызвать метод класса `Derived`
    cout << d3->DoSomething() << '\n';
    }
    else {
    cout << "d3 is null" << '\n';
    }

    // Output: d3 is null;
   ```

    Обратите внимание, что в предыдущей программе не произошло преобразование из типа `Base*` в тип `Derived*`, т.к. такое преобразование возможно только в обратную сторону: из базового в производный.
4. `const_cast`  
   Для преобразований:
   - Type -> const Type
   - const Type -> Type
   ```c++
    void func(double& d) { ... } {
    const double pi = 3.14;
    func( const_cast<double&>(pi) ); // No error.
    }
   ```
5. `reinterpret_cast` 
    
    [В чем смыслre interpret_cast?](https://ru.stackoverflow.com/questions/716240/%D0%92-%D1%87%D1%91%D0%BC-%D1%81%D0%BC%D1%8B%D1%81%D0%BB-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-reinterpret-cast)

    Этот указатель используется для приведения между несвязанными типами, например, `Type*` и `double` или, как в примере, `std::string` в тип `int`
    ```c++
    const char* str = "hello";
    int i = static_cast<int>(str); // error C2440: 'static_cast' : cannot
                    // convert from 'const char*' to 'int'
    int k = reinterpret_cast<int>(str); // Programming intent is clear. // However, it is not 64-bit safe.
    ```

## Вопрос 96

**Функциональная форма преобразования типа в c++. Её реализация.**

**Ответ:** 

Два устравших стиля, которые эквивалентны из-за оптимизаций компилятора, не нужно их использовать: 
- си-подобный 
- функциональный
```c++
double x = 10.3;
int y;
y = int (x);    // преобразование в функциональном стиле
y = (int) x;    // преобразование в стиле Си

//  в таких простых случаях лучше подходит оператор `static_cast`
```

## Вопрос 97

**Что требуется сделать, чтобы можно было использовать функциональную запись преобразования из класса A в класс B?**

**Ответ:** 

Если хотя бы один из типов приведения не является стандарным, то необходимо написать соответствующий конструктор преобразования, в других случаях компилятор сделает за вас всю работу 

## Вопрос 98

**Какие преобразования типа принимаются в расчёт только во время компиляции?**

**Ответ:** 

| Тип преобразования                  | Время исполнения |
|-------------------------------------|------------------|
| любое неявное преобразование        | Run-time         |
| explicit конструктор преобразования | Run-time         |
| static_cast                         | Compile-time*    |
| dynamic_cast                        | Run-time         |
| const_cast                          | ??               |
| reinterpret_cast                    | ??               |
| си-подобное преобразование          | Compile-time     |
| функциональное преобразование       | Compile-time     |

## Вопрос 98

**Преобразования указателей и ссылок в C++: особенности с учётом наследования.**

**Ответ:** 

Мне кажется, что здесь спрашивается про виртуальные деструкторы(кстати, конструкторы не могут быть виртуальными, подумайте почему).

Схема наследование в примере. LinkedList <-- Stack
```c++
    LinkedList<Programmer>* ptr_base = new LinkedList<Programmer>();
    // указателю ptr_base доступны методы только базового класса
    
    // при удалении указателя на базовый класс, который смотрит на экземпляр базового класса, должен быть вызван
    // деструктор базового класса. (ВЫПОЛНЕНО)
    delete ptr_base;

    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////

    Stack<Programmer> derived_stack;
    ptr_base = &derived_stack;

    // при удалении указателя на базовый класс, который смотрит на экземпляр производного класса сначала должен быть вызван
    // деструктор производного класса, потом деструктор базового, но это произойдет только в случае, если деструктор базового 
    // класса объявлен виртуальным. Иначе с самого начала будет вызван деструктор базового класса, а деструктор производного
    // класс не будет вызван. Произойдет утечка памяти, если под атрибуты производного класса была выделена память. (ВЫПОЛНЕНО)

    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////

    Stack<Programmer>* ptr_derevid = dynamic_cast<Stack<Programmer>*>(ptr_base); 
    // указатель ptr_derived смотрит на объект derived_stack.
  
    // поскольку указатель на производный класс смотрит на объект свого класс, то деструкторы должны быть вызваны 
    // в порядке наследования, т.е. сначала деструктор производного класса, потом деструктор базового класса. (ВЫПОЛНЕНО)

```