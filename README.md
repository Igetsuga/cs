# Практические работы по Обектно-ориентированному программированию

https://online-edu.mirea.ru/course/view.php?id=6362

---

## ~~Практическая работа №1 Перегрузка операций~~ 
- class: circle
  
---

## ~~Практическая работа №2 Массив~~
- class: ArrayParent
- subclass: ArrayChild

### Вопросы:
1. `quantity` и `capacity`, должны быть по разному устроены: `quantity`- количество элементов в массиве
   `capacity`- память для этих элементов в байтах, тогда `capacity = sizeof(type) * quantity` 
   
   **Ответ**: это, конечно, хорошо, но мы вводим  `capacity` в количестве элементов, для своего удобства, точнее для 
   нормальной работы функции `new` (подробнее с. **вопрос 3**)
 
2. не понятно как работает `double* ptr;`
   
   **Ответ**: это даст нам указатель на 1 конкретную ячейку. Конечно, сама по себе эта ячейка не массив, но на самом деле 
   после того как выполнится команда `ptr = new double[Dimension]` ячейка `double* ptr;` окажется началом нашего массива. 
   Но это не нулевой элемент массива. Вообщем это указатель на начало массива, потом именно по этому указателю будет индексация массива, т.е. 
   array\[index\] = array\[0\] + index * sizeof(type) ).
 
3. не понятно как работает `ptr = new double[Dimension]`
   
   **Ответ**: функция `new` **последовательно** выделяет память типа `double`(мы сами задаем какого типа будут элементы) для количества элементов равному `capacity`,      именно поэтому `capacity` у нас отвечает на вопрос: под сколько элементов выделять память, т.е. `capacity` лучше измерять в количесве элементов.
 
4. строка 66- деконструктор, если бы мы не проверяли условие `(ptr != NULL)`, то что тогда удаляла бы функция `delete` ?

   **Ответ**: вообще нужно ещё прочитать про ptrnull. А так если ptr == ptrnull, то ничего удалять не нужно, т.к. никакой памяти и так не выделено.  

5. сравнение `double` 

    **Ответ**: Нельзя сравнивать два числа с плавующей запятой между собой, из за того, что числа с плавующей запятой не могут быть представлены точно, по-этому мы не можем полагаться на оператор сравнения.

    Популярная практика сравнения такая:
    ```c++
    #include <cmath>
    #include <limits>

    bool is_equal(double x, double y) 
    {
        return std::fabs(x - y) < std::numeric_limits<double>::epsilon();
    }
    ```

6. Может ли быть у конкретного класса абстрактный подкласс? Абстрактный класс единственный во всем дереве классов? Он обязательно должен быть корнем дерева классов?

    **Ответ**: да, может. Абстрактных классов может быть несколько

7. Зачем в родительском классе объявлять методы без тела? Например: `int tree(vector<int>& graph);`

    **Ответ**: если, например, родительский класс абстрактный, то нужно будет эти методы переопределить для каждого производного класса, а потом через указатель на базовый класс вызывать этот метод для каждого из подклассов.  Например: родительский абстрактный класс - `Mammal` имеет метод `Speech()`, но для каждого из подклассов `Cow` , `Dog` , `People` , `Lion` этот метод должен быть определен по разному. По всей видимости это еще один способ сделать метод виртуальным.

8. Должен ли конструктор копий `ArrayMaster(const ArrayMaster& array_existing)` возвращать что-то? А преобразователь типов?

    **Ответ**: да, конструктор копий должен возвращать объект класса. А преобразователь типов - нет, т.к. преобразователь типов это конструктор, конструктор и так все делает сам. 

    Когда используется конструктор копирования:
   - передача объекта класса в функцию
   - возврат объекта класса из функции
   -  operator=

9. Что хранит указатель `ptr_` указатели или ссылки?

    **Ответ**:

10. `double get_element(int index)` или `double& get_element(int index)`
   
    **Ответ**: Вариант 1, иначе будет нарушена инкапсуляция.

11. У меня есть два конструктора `ArrayMaster(int Dimension = 100)` и `ArrayMaster(int quantity = 100, double value = 0)` если я вызову один из них, не указав аргументы, который из них сработает?

    **Ответ**: наличие двух конструкторов по умолчанию не допускается.

12. Зачем возвращать `*this` в методе `ArrayMaster& operator=(const vector<double>& vector)`? 

    **Ответ**: для того, что сработал цепной метод `operator=` , т.е. `A = B = C = D`. Если не возвращать `*this`, то на первом шаге `C = D` ничего не вернется и следующий шаг будет выглядеть так: `B = ...` Непонятно, что должно произойти с B
    
    Кстати выполнение такого цепного метода начнется справа-налево. Как итог будет выполнено следующее: `A = D`
    
    По шагам `A = B = C = D` :
        
        1. C = D
        2. B = C
        3. A = B (<=> A = D)

13. Что должен возвращать оператор `=` ссылку или самого себя(т.е. свою копию?) 

    **Ответ**: ссылку, потому что это быстрее и требует меньше дополнительной памяти относительно постоянного копирования.

14. Как работает деструктор производного массива? Он вызывает деструктор родительского? Если это так, тогда зачем его вообще объявлять в производном классе?

      **Ответ**: конструктор при создании производного класса спускается сверху-вниз от родительского к производному, деструктор наоборот поднимается снизу вверх от нашего производного к родительскому. Почему именно так? 

      Построим аналогию. При создании объекта производного типа создается объект родильского класса, этот объект родительского класса удобно считать за ядро объекта производного типа. Сначало создается ядро, после - оболочка. Сначала разрушается оболочка, потом - ядро. 
      
15. Понятно как `capacity_` связано с выделением памяти в конструкторе. Но потом при инкрементировании `capacity_` количество выделенной памяти никак не изменяется, что делать? Как тогда происходит выделение новой памяти?

    **Ответ**: действительно `capacity_` никак физически не связано выделенной памятью, это лишь счетчик, чтобы недопустить переполнения. Удалять массив, заново выделять память в нужном количестве, запонять массив.

16. Преобразователь типов? Явный? Конструктор?

---

## ~~Практическая работа №3 Множественное наследование~~

---

## ~~Практическая работа №4 Строки~~

---
