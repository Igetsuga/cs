# Практические работы по Обектно-ориентированному программированию

## ~~Практическая работа №1~~ 
- class: circle

## Практическая работа №2
- class: ArrayParent
- subclass: ArrayChild

Вопросы:
1. `quantity` и `capacity`, должны быть по разному устроены: `quantity`- количество элементов в массиве
   `capacity`- память для этих элементов в байтах, тогда `capacity = sizeof(type) * quantity` 
   
   **Ответ**: это, конечно, хорошо, но мы вводим  `capacity` в количестве элементов, для своего удобства , точнее для 
   нормальной работы функции `new` (подробнее с. **вопрос 3**)
 
2. не понятно как работает `double* ptr;`
   
   **Ответ**: это даст нам указатель на 1 конкретную ячейку. Конечно, сама по себе эта ячейка не массив, но на самом деле 
   после того как выполнится команда `ptr = new double[Dimension]` ячейка `double* ptr;` окажется началом нашего массива. (Скорее всего
   это не нулевой элемент массива. Вообщем это указатель на начало массива, потом именно по этому указателю будет индексация массива, т.е. 
   array\[index\] = array\[0\] + index * sizeof(type) ).
 
3. не понятно как работает `ptr = new double[Dimension]`
   
   **Ответ**: функция `new` **последовательно** выделяет память типа `double` для количества элементов равному `capacity`, именно поэтому `capacity`
   у нас отвечает на вопрос: под сколько элементов выделять память, т.е. `capacity` лучше измерять в количесве элементов.
 
4. строка 66- деконструктор, если бы мы не проверяли условие `(ptr != NULL)`, то что тогда удаляла бы функция `delete` ?

   **Ответ**: вообще нужно ещё прочитать про ptrnull. А так если ptr == ptrnull, то ничего удалять не нужно, т.к. никакой памяти и так не выделено.  

5. количество элементов в массиве `int arrSize = sizeof(arr)/sizeof(arr[0]);` или `std::array::size` 

6. сравнение `double` , (строка 221)

7. Может ли быть у конкретного класса абстрактный подкласс? Абстрактный класс единственный во всем дереве классов? Он обязательно должен быть корнем дерева классов?
