# Практические работы по Обектно-ориентированному программированию

## ~~Практическая работа №1~~ 
- class: circle

## Практическая работа №2
- class: ArrayParent
- subclass: ArrayChild

Вопросы:
1. `quantity` и `capacity`, должны быть по разному устроены: `quantity`- количество элементов в массиве
   `capacity`- память для этих элементов в байтах, тогда `capacity = sizeof(type) * quantity` 
   
   **Ответ**: это, конечно, хорошо, но мы вводим  `capacity` в количестве элементов, для своего удобства, точнее для 
   нормальной работы функции `new` (подробнее с. **вопрос 3**)
 
2. не понятно как работает `double* ptr;`
   
   **Ответ**: это даст нам указатель на 1 конкретную ячейку. Конечно, сама по себе эта ячейка не массив, но на самом деле 
   после того как выполнится команда `ptr = new double[Dimension]` ячейка `double* ptr;` окажется началом нашего массива. (Скорее всего
   это не нулевой элемент массива. Вообщем это указатель на начало массива, потом именно по этому указателю будет индексация массива, т.е. 
   array\[index\] = array\[0\] + index * sizeof(type) ).
 
3. не понятно как работает `ptr = new double[Dimension]`
   
   **Ответ**: функция `new` **последовательно** выделяет память типа `double`(мы сами задаем какого типа будут элементы) для количества элементов равному `capacity`,      именно поэтому `capacity` у нас отвечает на вопрос: под сколько элементов выделять память, т.е. `capacity` лучше измерять в количесве элементов.
 
4. строка 66- деконструктор, если бы мы не проверяли условие `(ptr != NULL)`, то что тогда удаляла бы функция `delete` ?

   **Ответ**: вообще нужно ещё прочитать про ptrnull. А так если ptr == ptrnull, то ничего удалять не нужно, т.к. никакой памяти и так не выделено.  

5. количество элементов в массиве `int arrSize = sizeof(arr)/sizeof(arr[0]);` или `std::array::size` 

6. сравнение `double` , (строка 221)

7. Может ли быть у конкретного класса абстрактный подкласс? Абстрактный класс единственный во всем дереве классов? Он обязательно должен быть корнем дерева классов?

8. Зачем в родительском классе объявлять функции без тела? Например: `int tree(vector<int>& graph);`

9. Должен ли конструктор копий `ArrayMaster(const ArrayMaster& array_existing)` возвращать что-то? А преобразователь типов? 

10. `double get_element(int index)` или `double& get_element(int index)`
   
      **Ответ**: Вариает 1, т.к. `ptr_` это указатель на ячейку, которая хранит другие указатели(или ссылки?) на неразрывную последовательность ячеек памяти, 
      обращение через `ptr_[index]` возвращает именно ссылку, но через. Не знаю там и так и так, наверное, может быть нужно самому попробовать ручками что-то поделать.

11. Что хранит указатель `ptr_` указатели или ссылки?

12. У меня есть два конструктора `ArrayMaster(int Dimension = 100)` и `ArrayMaster(int quantity = 100, double value = 0)` если я вызову один из них, не указав аргументы, который из них сработает?

13. Зачем возвращать `*this` в методе `ArrayMaster& operator=(const vector<double>& vector)`?

14. Что должен возвращать оператор `=` ссылку или самого себя(т.е. свою копию?)?

15. Как работает деструктор производного массива? Он вызывает деструктор родительского? Если это так, тогда зачем его вообще объявлять в производном классе?

      **Ответ**: конструктор при создании производного класса спускается сверзу-вниз от родительского к нашему производному, деструктор наооборот поднимается снизу вверх от нашего производного к родительскому. Почему и зачем так, я пока не понимаю.
      
16. Понятно как `capacity_` связано с выделением памяти в конструкторе. Но потом при инкрементировании `capacity_` количество выделенной памяти никак не изменяется, что делать? Как тогда происходит выделение новой памяти?
