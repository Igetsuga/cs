# Вопросы 100-107


## Вопрос 100

**Инициализация объектов классов, перечислите все её способы и проиллюстрируйте примерами.**

**Ответ:** для начала отметим, что тема инициализации в c++ очень глубока и сложна, каждый стандарт содержал дополнения, но тем не менее все еще ведется разработка. Если хотите супер подробно, и  если вам не жалко для этого пары часов, то читайте эту [интересную статью](https://habr.com/ru/company/jugru/blog/469465/). Начнем инциализаций, которые перекочевали в C++ из C.

1.  **Инициализация по умолчанию**
    
    На самом деле это неудачное название для этого вида инициализации, ведь, честно говоря, это даже не совсем инициализация, а больше похоже на объявление. Пример 1
    ```c++
    class Human {
    public:
        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel;
        return chel._age; // неопределенное поведение
    }
    ```
    Мы здесь успользовали вместо `struct` - `class`, а этого вообще-то не было в C, но не будем на этом заострять внимание, просто мы так захотели. Упомянем здесь еще две инициализации. Первая - `member initializer list`, что была добавлена в C++98, вторая - `default member initializers`, что была добавлена в C++11. 
    
    >Пример 2. (Но такое решение проблемы не оптимальное, поскольку это необходимо делать в каждом конструкторе, и об этом легко забыть. Кроме того, инициализация идёт в порядке, в котором переменные объявлены, а не в порядке member initializer list)
     ```c++
    class Human {
    public:
        Human() : age(20), chromosomes(48) {} // member initialiser list
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_;
        int _chromosomes_;
    };

    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >Пример 3. (Позволет инициализировать все переменные одновременно, и это даёт уверенность, что все элементы инициализированы)
    ```c++
        class Human {
    public:
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_ = 20;         // default member initialisers
        int _chromosomes_ = 48; // default member initialisers
    };

    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >(Хабр) Рекомендация: когда можете, всегда используйте DMI (default member initializers).

2. **Копирующая инициализация**
    ```c++
    int variable = 42;
    ```

    В этом случае мы указываем переменную и через знак равенства — её значение. Отметим, что копирующая инициализация также используется, когда аргумент передаётся в функцию по значению, или когда происходит возврат объекта из функции по значению. Мы смотрим на знак равенсва и думаем: "Так это же присвоение значения...". Оказывается, что нет. **Копирующая инициализация — это не присвоение значения.**
    
3. **Агрегатная инициализация**

    Используется для массивов и агрегатных классов (_т.е. набор публичных полей, объединеных в `class`_). 
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel {20, 48};   // <=> Human chel = {20, 48};
        std::cout << chel.get_age() << '\n'; // Вывод: 20

        Human chuvak {20}; // остальные значения инициализируются 0
        std::cout << chel.get_chromosomes() << '\n' // Вывод: 0
    }
    ```
    >Агрегатная инициализация на самом деле использует копирующую инициализацию для каждого элемента.

4. **Статическая инициализация**
    
    Шанс, что у вас про это спросят стремится к 0, но для умников и умничек, мы не забили на него. Суть статической инициализации в том, чтобы инициализироавть статический объект (_для этого объекта ппамять выделяется только 1 раз, а существует он на протяжении работы всей программы_) на стадии компиляции (не знаю примера, зачем это нужно).
    
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        static Human chel { 20, 48 };   // <=> Human chel = {20, 48};
        
        std::cout << chel.get_age() << '\n'; // Вывод: 20
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
    }
    ```

    Здесь стоит быть аккуратным, поскольку если где-то еще появляется статический объектр, который использует `chel`, возникнет проблема, что первое из них инициализировать, на самом деле это решается через `constexpr`, но мы об этом ничего не знаем, а поскольку ответ на первый вопрос мы пишем уже 3 часай, то разбираться в этом сил нет.

5. **Прямая инициализация**
    
    > До этого момента мы ни разу не использовали конструкторы, потому что все предыдущие инициализации пришли из C, где конструкторов не было.

    Прямая инициализация для базовых типов это абсолютно то же самое, что и копирующая инициализация. Но для пользовательских типов при копирующей инициализации мы не могли сразу инициализировать несоколько атрибутов, а здесь мы можем передать несколько значей, поэтому можем инициализировать несколько полей. Но это не все отличия, чтобы узнать остальные читай [статью](https://habr.com/ru/company/jugru/blog/469465/)

    Пример 4
    ```c++
    class Human {
    public:
        explicit Human (int age = 20, int chromosomes = 48) { // 3 строка
        _age = age;
        _chromosomes = chromosomes;
        };

        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        static Human chel { 8, 47 };   // Вызов конструктора из 3 строки;
        
        std::cout << chel.get_age() << '\n'; // Вывод: 8
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 47
    } 
    ```
    > Кстати скобки `()`, возможно с параметрами, при инциализации всегда вызывают конструктор.

6. **Инициализация значением**








___

## Вопрос 101

**Что нужно сделать, чтобы имелась возможность инициализировать значение объекта в месте его определения?**
    
**Ответ:** 

мне кажется, что ждут ответ типа: "если мы говорим про пользовательские классы, то - написать соответсвующий конструктор". Но вы посмотрите на первые 4 пункта из вопроса 100, там нигде явный конструктор не нужен был, хотя возможно компилятор и создавал его сам. **Поэтому, кто знает ответ на этот вопрос, скажите мне, плиз!!**

___

## Вопрос 102

**Что нужно сделать, чтобы имелась возможность инициализировать значение объекта в месте его определения?**

**Ответ:** да
```c++
class Human {
public:
    const int get_age() const noexcept { return _age; }
    const int get_chromosomes() const noexcept { return _chromosomes; }

    int _age;
    int _chromosomes;
};

int main() {
    static Human chel { 8, 47 };   // <=> Human chel = {20, 48};
    
    std::cout << chel.get_age() << '\n'; // Вывод: 20
    std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
}
```

___

## Вопрос 103

**Что нужно сделать, чтобы имелась возможность инициализировать значение объекта в месте его определения?**
    
**Ответ:** да
