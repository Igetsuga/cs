# Вопросы 100-107

**Объявление** - выделение памяти под объект.  
За объявление отвечают аллокаторы(не совсем точная инфа, ведь есть и другие штучки, отвечающие за выделение памяти)


**Присваивание** - задание значений для полей объекта.  
За присваивание отвечает `operator=`

**Инициализация** - объявление + присваивание одновременно.  
За инициализацию отвечают конструкторы.

___
## Вопрос 100

**Инициализация объектов классов, перечислите все её способы и проиллюстрируйте примерами.**

> [Инициализация в C++]()

**Ответ:** для начала отметим, что тема инициализации в c++ очень глубока и сложна, каждый стандарт содержал дополнения, но тем не менее все еще ведется разработка. Если хотите супер подробно, и  если вам не жалко для этого пары часов, то читайте эту [интересную статью](https://habr.com/ru/company/jugru/blog/469465/). Начнем инциализаций, которые перекочевали в C++ из C.

1.  **Инициализация по умолчанию**
    
    На самом деле это неудачное название для этого вида инициализации, ведь, честно говоря, это даже не совсем инициализация, а больше похоже на объявление. Пример 1
    ```c++
    class Human {
    public:
        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel;
        return chel._age; // неопределенное поведение
    }
    ```
    Мы здесь успользовали вместо `struct` - `class`, а этого вообще-то не было в C, но не будем на этом заострять внимание, просто мы так захотели. Упомянем здесь еще две инициализации. Первая - `member initializer list`, что была добавлена в C++98, вторая - `default member initializers`, что была добавлена в C++11. 
    
    >Пример 2. (Но такое решение проблемы не оптимальное, поскольку это необходимо делать в каждом конструкторе, и об этом легко забыть. Кроме того, инициализация идёт в порядке, в котором переменные объявлены, а не в порядке member initializer list)
     ```c++
    class Human {
    public:
        Human() : age(20), chromosomes(48) {} // member initialiser list
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_;
        int _chromosomes_;
    };

    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >Пример 3. (Позволет инициализировать все переменные одновременно, и это даёт уверенность, что все элементы инициализированы)
    ```c++
        class Human {
    public:
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_ = 20;         // default member initialisers
        int _chromosomes_ = 48; // default member initialisers
    };

    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >(Хабр) Рекомендация: когда можете, всегда используйте DMI (default member initializers).

2. **Копирующая инициализация**
    ```c++
    int variable = 42;
    ```

    В этом случае мы указываем переменную и через знак равенства — её значение. Отметим, что копирующая инициализация также используется, когда аргумент передаётся в функцию по значению, или когда происходит возврат объекта из функции по значению. Мы смотрим на знак равенсва и думаем: "Так это же присвоение значения...". Оказывается, что нет. **Копирующая инициализация — это не присвоение значения. Оператор присваяивания здесь нечего не делает!**
    
3. **Агрегатная инициализация**

    Используется для массивов и агрегатных классов (_т.е. набор публичных полей, объединеных в `class`_). 
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel {20, 48};   // <=> Human chel = {20, 48};
        std::cout << chel.get_age() << '\n'; // Вывод: 20

        Human chuvak {20}; // остальные значения инициализируются 0
        std::cout << chel.get_chromosomes() << '\n' // Вывод: 0
    }
    ```
    >Агрегатная инициализация на самом деле использует копирующую инициализацию для каждого элемента.

4. **Статическая инициализация**
    
    Шанс, что у вас про это спросят стремится к 0, но для умников и умничек, мы не забили на него. Суть статической инициализации в том, чтобы инициализироавть статический объект (_для этого объекта ппамять выделяется только 1 раз, а существует он на протяжении работы всей программы_) на стадии компиляции (не знаю примера, зачем это нужно).
    
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        static Human chel { 20, 48 };   // <=> Human chel = {20, 48};
        
        std::cout << chel.get_age() << '\n'; // Вывод: 20
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
    }
    ```

    Здесь стоит быть аккуратным, поскольку если где-то еще появляется статический объектр, который использует `chel`, возникнет проблема, что первое из них инициализировать, на самом деле это решается через `constexpr`, но мы об этом ничего не знаем, а поскольку ответ на первый вопрос мы пишем уже 3 часай, то разбираться в этом сил нет.

5. **Прямая инициализация**
    
    > До этого момента мы ни разу не использовали конструкторы, потому что все предыдущие инициализации пришли из C, где конструкторов не было.

    Прямая инициализация для базовых типов это абсолютно то же самое, что и копирующая инициализация. Но для пользовательских типов при копирующей инициализации мы не могли сразу инициализировать несоколько атрибутов, а здесь мы можем передать несколько значей, поэтому можем инициализировать несколько полей. Но это не все отличия, чтобы узнать остальные читай [статью](https://habr.com/ru/company/jugru/blog/469465/)

    Пример 4
    ```c++
    class Human {
    public:
        explicit Human (int age = 20, int chromosomes = 48) { // 3 строка
        _age = age;
        _chromosomes = chromosomes;
        };

        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        static Human chel { 8, 47 };   // Вызов конструктора из 3 строки;
        
        std::cout << chel.get_age() << '\n'; // Вывод: 8
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 47
    } 
    ```
    > Кстати скобки `()`, возможно с параметрами, при инциализации всегда вызывают конструктор.

6. [**Инициализация значением**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%B8%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F.-,%D0%98%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20(C%2B%2B03),-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D0%B4%D1%91%D0%BC%20%D0%BA%20%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D1%8E%D1%89%D0%B5%D0%B9)

   **Правило такое: если существует определённый пользователем конструктор по умолчанию, инициализация значением вызывает этот конструктор, в противном случае возвращается нуль.**

7. [**Универсальная инициализация (C++11)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%3D%20default.-,%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20(C%2B%2B11),-%D0%92%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8%20%D0%A1)

8. [**Назначенная инициализация (С++20)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D1%83%D0%BB%D1%83%D1%87%D1%88%D0%B8%D1%82%D1%8C.-,%D0%9D%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20(%D0%A1%2B%2B20),-%D0%A2%D0%B5%D0%BF%D0%B5%D1%80%D1%8C%20%D0%B4%D0%B0%D0%B2%D0%B0%D0%B9%D1%82%D0%B5%20%D0%BF%D0%BE%D0%B3%D0%BE%D0%B2%D0%BE%D1%80%D0%B8%D0%BC)

9. [**Прямая инициализация агрегатных типов (C++20)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%B4%D0%BB%D1%8F%20%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0.-,%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B0%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D0%BD%D1%8B%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20(C%2B%2B20),-%D0%9D%D0%B0%D0%BA%D0%BE%D0%BD%D0%B5%D1%86%2C%20%D0%B2%20%D0%A1) 
___

## Вопрос 101

**Что нужно сделать, чтобы имелась возможность инициализировать значение объекта в месте его определения?**
    
**Ответ:** 

мне кажется, что ждут ответ типа: "если мы говорим про пользовательские классы, то - написать соответсвующий конструктор". Но вы посмотрите на первые 4 пункта из вопроса 100, там нигде явный конструктор не нужен был, компилятор сам создавал свой конструктор для этого. 
> На самом деле, если мы не написали **никакой** конструктор для `struct`, `class`, `union`, то компилятор всегда сможет сделать это сам, при этом запихнет он его в публичнй раздел нашей структуры. См. [здесь](https://en.cppreference.com/w/cpp/language/default_constructor#:~:text=If%20no%20user,of%20its%20class.)

Поэтому мы бы ответили, что "ничего, ибо компилятор позволит нам это сделать".
___

## Вопрос 102

**Можно ли проинициализировать значение объекта в месте его определения без вызова конструктора?**

мы не можем ответить на этот вопрос. 

В в C были структуры, но в C не было конструкторов, поэтому инициализация структур там была без конструкторов. В C++ появились конструкторы, и если мы не объявляли никакого конструктора в нашей структуре (struct, union, class), то за нас это сделает компилятор. Значит ли это, что в C++ теперь нельзя инициализировать структуру совсем без конструктора( и без того, что создаст компилятор )??

___

## Вопрос 103

**Инициализирующий конструктор: назначение, способ оформления, способы применения, отличие от перегрузки операции присваивания.**
    
**Ответ:**  
- **Инициализирующий конструктор** - любой ранее перечисленный конструктор. 
- Способ оформления. Конструктор - функция-метод и её название обязательно должно совпадать с названием класса. Параметры конструктора могут отсутствовать, и тогда такой конструктор называется конструктором по умолчанию (= инициализация по умолчанию) (_default constructor_). А может содержать какие-то параметры, которые будут как-то учитываться при создани экземпляров структуры.
- Способ применения. Он вызывается автоматически при создании экземпляра структуры. Но конструктор объекта можно вызвать почти явно. С помощью оператора `new`, который сначала выделит память, а потом вызовет соответствующий параметрам конструктор.
- КОНСТРУКТОР != ОПЕРАТОР ПРИСВАИВАНИЯ. Пример
    ```c++
    class Human {
    public:

        explicit Human (int age = 20, int chromosomes = 48) {
            _age = age;
            _chromosomes = chromosomes;
        }

        explicit Human (const Human& other) {
            _age = other._age;
            _chromosomes = other._chromosomes;
        }

        Human& operator= (const Human& other) {
            _age = other._age;
            _chromosomes = other._chromosomes;
        }

        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }



        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel(8, 47);   // <=> Human chel = {20, 48};

        Human chuvak = chel; // строка 32

        std::cout << chel.get_age() << '\n'; // Вывод: 20
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
    }
    ```

    В строке 32 будет вызван конструктор копий, даже если он не опрделен и НИКОГДА оператор присваиавния. 
    - Конструктор нужен, чтобы инициализировать поля структуры, т.е. раньше их не было, после появились
    - Оператов присваивания нужен для того, чтобы присвоить уже существующим полям одного объекта значения другого объекта.

___

## Вопрос 104

**Понятие ссылки: назначение, способы применения, побочные эффекты.**
    
**Ответ:** 

> Достаточно традиционный взгляд — это считать ссылку «замаскированным» константным указателем. Но Страуструп и другие авторы, например Стефан Дьюхэрст [Dewhurst], считают такую точку зрения неверной и настаивают, что ссылка — это просто псевдоним переменой, на которую она ссылается.

Указатель в свою очередь это некий объект, значением которого является адресс в памяти другого объекта. 

> Синтаксис языка не позволяет различить целевой объект и саму  ссылку — все операции над ссылкой на самом деле являются операциями над объектом. Как следствие этого:  
>   1. Ссылку нельзя переназначить на другой объект - связь между ссылкой и переменной «до гробовой доски»
>   2. Нельзя сравнить адрес, содержащийся в ссылке, с адресом другого объекта или NULL

> Из этих свойств в свою очередь следуют другие ограничения:
> 
>    3. Ссылка должна быть инициализирована при создании (поскольку инициализировать ее позже не возможно)
>    4. Ссылка не может содержать нулевой адрес (поскольку проверить и обработать это невозможно)

В C++ есть потребность в _чистых указателях_ - указатели, для которых система типов гарантирует, что они инициализированны и не они не `nullptr` или `NULL`, свойства 3, 4 как раз организуют чистые указатели, эти же свойства есть главное достоинство ссылок.

1. **Назначение**
        
    Ссылки были созданы для того, чтобы где-то упросить работу с указателями и для того, чтобы служить `l-value` значениями при возврате их из функций. Указатели с последним не справляются, вот пример:
    ```c++
    int* foo(int* x) {
        return x;
    }

    int main() {
        int x = 42;
        int* ptr = &x;

        foo(ptr) = 7; // строка 12
    }
    ``` 

    Значение функции `foo(int*)` не является левосторонним значением, в строке 12 ошибка. В качестве еще одного примера можно привести `operator[]`, если бы он был реализован через указатели, у нас никогда бы не получилось следующее:
    ```c++
    int main() {
        std::vector<int> vector(42, 0);
        int array [42];
        
        vector[2] = 42;  // это не получилось бы 
        array[2] = 42;   // это не получилось бы

        std::cout << array[2] << '\n' << vector[2]; 

        
        return 0;
    }
    ```
    Вывод:
        
        42
        42

    На самом деле ради последнего и создали новый **тип**, который назвали ссылочным - ссылками. 

2. **Способы применения**
    
    инициализируете ссылку -> используете ссылку

3. **Побочные эффекты**

    все, что происходит с ссылкой происходит и с объектом.
___

## Вопрос 105

**Всегда ли передача по ссылке лучше передачи по значению?**
    
**Ответ:** 

Короткий ответ - да, в общем случае это так. Почему? Потому, что здесь производительность считается в количестве запусков конструктора копирование, т.к. он довольно требовательный. Из всех трех вариантов (передача по ссылке на константу, передача по значению, перемещение(_еще один метод передачи значения в функцию_)) самым выгодным в общем случае является метод передачи по ссылке на константу, который вызывает конструктор копирования не сильно больше, чем при перемещении, но который не так сильно раздувает код, по сравнению с перемещением(отдельные методы нужно будет написать), что улучшает читабельность, ускоряет отладу, упрощает поддержание кода, а это **ОЧЕНЬ-ОЧЕНЬ** важно.

Длинный(очень) ответ - не всегда, есть частные случаи, когда это не так, а передача по значению позволит ускорить программу. Читай эту [статью](http://scrutator.me/post/2018/07/30/value_vs_reference.aspx).

___

## Вопрос 106

**Всегда ли передача по ссылке лучше передачи по указателю?**
    
**Ответ:** 

Честно говоря, это практически однинаковые вещи, поскольку ссылка это все же разыменованный указатель(сейчас мы склоняемя к этой точке зрения), то реализция передачи значений по ссылке на константу основана на передаче по указателю.

Минусы:  
- усложнение синтаксиса
- дополнительные проверки `!= nullptr`, иначе прога обвалиться
- адрессная арифметика **ОЧЕНЬ-ОЧЕНЬ** не безопастна 
- разыменование медленнее, чем прямой доступ по значению
  
Плюсы:  
- те же, что и у передачи по ссылке на константу


Когда можно использовать передачу по указателю: **только** при работе с обычными массивами.

**Правило хорошего тона:** использовать передачу по ссылке, вместо передачи по адресу, когда это возможно.

___

## Вопрос 107

**Всегда ли можно обойтись без ссылки?**
    
**Ответ:** 

Начнем с передачи аргументов по константой ссылке (_т.е. оптимизированная передача по значению_).

Чтобы принять правильно решение относительно этой оптимизации надо учесть:
- Стоимость выделения памяти под копию объекта
- Стоимость конструктора копирования и деструктора
- Стоимость разыменования ссылки внутри функции
- Соглашение о вызове для конкретной функции — решение может быть разным при использовании регистров и стека
- Возможный выигрыш от оптимизаций, которые компилятор может применить зная что никакие аргументы функции не являются псевдонимами.

Поскольку каждый раз отвечать на эти вопросы очень трудоемко, то возложим это на компилятор, он будет принимать решения во время компиляции, вместо нас. Но такой подход тоже имеет свои недостатки, например, компилятор должен принять решение не учитывая факторы скрытые в реализации функции, а это может сыграть решающую роль.

Теперь что делать с конструктором копирования? Когда мы будем передавать объекты в функцию в качестве параметров, то будет вызываться конструктор копирования. Но если передавать к конструктор копирования объекты как пераметры, то будет вызываться тот же конструктор копировая => бесконечная рекурсия, это исправляется добовлением исключений в конструктор копирования, так чтобы в конструктор копирования объектры передавались по указателю.

Теперь что делать с возвратом `l-value` значений? Что-то с этим сделать можно.
```c++
a[i] = b;
*a.operator[](i) = b;
(++i) = x;
*i.operator++() = x;
(x = y) = z;
*x.operator=(y) = z;
*p = d;
*p.operator->() = d;
```
Но во всех остальных случаях это может противоречить здравому смыслу.

**Итог:** да, в C++ можно обойтись без ссылок, но цена потери довольно высока